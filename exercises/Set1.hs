-- 欢迎来到 Haskell Mooc 的第一个练习集！Edit this
-- 根据指示编辑本文件，并通过
--
--   stack runhaskell Set1Test.hs
--
-- 验证你的答案
-- 你也可以在 GHCi 中通过
--
--   stack ghci Set1.hs
--
-- 尝试你的答案
--
-- 本习题集包含如下练习
--   * 定义函数
--   * 基础表达式
--   * 模式匹配
--   * 递归

module Set1 where

import Mooc.Todo

------------------------------------------------------------------------------
-- Ex 1: 定义变量 one 和 two 。它们应当具有 Int 类型，并分别拥有值 1 和 2 。


------------------------------------------------------------------------------
-- Ex 2: 定义函数 double ，其类型为 Integer->Integer 。
-- double 应当接受一个参数并返回其二倍。

double :: Integer -> Integer
double x = todo

------------------------------------------------------------------------------
-- Ex 3: 使用先前练习中的函数 double 来定义函数 quadruple ，返回其参数的四倍。

quadruple :: Integer -> Integer
quadruple x = todo

------------------------------------------------------------------------------
-- Ex 4: 定义函数 distance 。它接受四个类型为 Double 的参数：
-- x1, y1, x2, y2 并返回点 (x1,y1) 与 (x2,y2) 间的（欧氏）距离。
--
-- 为 distance 提供一个类型签名，比如 distance :: something 。
--
-- 注：如果你不记得距离如何计算，其公式为：
--  ((x 方向距离) 的平方 + (y 方向距离) 的平方) 开二次方根
--
-- 实例：
--   distance 0 0 1 1  ==>  1.4142135...
--   distance 1 1 4 5  ==>  5.0

distance = todo

------------------------------------------------------------------------------
-- Ex 5: 定义函数 eeny ，对于偶数输入返回 "eeny" 而对奇数输入返回 "meeny" 。
--
-- 注：看看内建函数 "even"

eeny :: Integer -> String
eeny = todo

------------------------------------------------------------------------------
-- Ex 6: 这是课程资料中的 checkPassword 函数。
-- 修改至使其接受两个密码： "swordfish" 与 "mellon" 。

checkPassword :: String -> String
checkPassword password = if password == "swordfish"
                         then "You're in."
                         else "ACCESS DENIED!"

------------------------------------------------------------------------------
-- Ex 7: 一个邮政服务按照如下方式为包裹计费。
-- 不超过 500 克的包裹收费 250 分。
-- 超过 500 克但不超过 5000 克的包裹收费 300 分 + 1 分/克。
-- 超过 5000 克的包裹固定收费 6000 分。
--
-- 编写函数 postagePrice ，其接受包裹克数作为参数，并返回其费用（单位为分）。

postagePrice :: Int -> Int
postagePrice = todo

------------------------------------------------------------------------------
-- Ex 8: 定义函数 isZero ，当输入参数为 0 时返回 True ，其余情况返回 False 。
-- 为 isZero 提供一个类型签名。
--
-- 使用模式匹配！不要使用比较！
--
-- 注：记住， haskell 中布尔值的类型是 Bool

isZero = todo

------------------------------------------------------------------------------
-- Ex 9: 使用递归实现函数 sumTo 使得
--   sumTo n
-- 计算 1+2+...+n 的和

sumTo :: Integer -> Integer
sumTo = todo

------------------------------------------------------------------------------
-- Ex 10: power n k 应当计算 n 的 k 次方 (即为 n^k)
-- 使用递归。
-- 无需处理 k 为负值的情形。

power :: Integer -> Integer -> Integer
power = todo

------------------------------------------------------------------------------
-- Ex 11: ilog3 n 应为你可以将提供的数字归零前除以三（向下取整）的次数。
--
-- 例如， ilog3 20 ==> 3 因为
--   20/3 = 6.66 (向下取整为 6)
--   6/3 = 2
--   2/3 = 0.666 (向下取整为 0)
--
-- 使用递归定义 ilog3 。 使用函数 "div" 整除，它已进行下取整。
--
-- 更多实例：
--   ilog3 2 ==> 1
--   ilog3 7 ==> 2

ilog3 :: Integer -> Integer
ilog3 = todo
